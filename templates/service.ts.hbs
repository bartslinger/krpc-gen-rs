/* eslint-disable no-unused-vars */
// Generated file DO NOT EDIT
import Long from "long";
import { KRPCConnection } from "../../services/connection";
import * as krpc from "../proto/krpc";
import * as encoding from "../../services/encoding";
import ByteBuffer from "bytebuffer";
ByteBuffer.DEFAULT_ENDIAN = true;

{{#each enumerations as |enumeration| }}
export enum {{{enumeration.name}}} {
  {{#each enumeration.values as |value|}}
  {{{value.name}}} = {{{ value.id }}},
  {{/each}}    
}

{{/each}}
export class {{{ service_name }}} {
  private conn: KRPCConnection;
  constructor(conn: KRPCConnection) {
    this.conn = conn;
  }

  {{#each service_methods as |method|}}
  async {{{ method.name }}}({{{ method.arguments_signature }}}): Promise<{{{ method.return_type_signature }}}> {
    const conn = this.conn;
    {{#if method.arguments }}
    const args: krpc.Argument[] = [];
    {{#each method.arguments as |argument|}}
    {{#if argument.optional}}
    if ({{{ argument.name }}} !== undefined) {
    {{/if}}
    args.push({
      position: {{{ argument.position }}},
      value: {{{ argument.encoder_function }}}({{{ argument.value }}}),
    });
    {{#if argument.optional}}
    }
    {{/if}}
    {{/each}}
    {{else}}
    const args: Array<krpc.Argument> = [];
    {{/if}}
    const procedureCall = krpc.ProcedureCall.fromPartial({
      service: "{{{ ../service_name }}}",
      procedure: "{{{ procedure }}}",
      arguments: args,
    });
    // eslint-disable-next-line no-unused-vars
    const result = await new Promise<krpc.ProcedureResult>(
      (resolve, reject) => {
        this.conn.scheduleProcedureCall({
          procedureCall,
          resolve,
          reject,
        });
      }
    );
    {{#if before_return }}
    {{{ before_return }}}
    {{/if}}
    return {{{ decoder_function }}};
  }

  {{/each}}

  {{#each service_getters_setters as |method|}}
  async {{{ method.name }}}({{{ method.arguments_signature }}}): Promise<{{{ method.return_type_signature }}}> {
    const conn = this.conn;
    {{#if method.arguments }}
    const args: krpc.Argument[] = [];
    {{#each method.arguments as |argument|}}
    {{#if argument.optional}}
    if ({{{ argument.name }}} !== undefined) {
    {{/if}}
    args.push({
      position: {{{ argument.position }}},
      value: {{{ argument.encoder_function }}}({{{ argument.value }}}),
    });
    {{#if argument.optional}}
    }
    {{/if}}
    {{/each}}
    {{else}}
    const args: Array<krpc.Argument> = [];
    {{/if}}
    const procedureCall = krpc.ProcedureCall.fromPartial({
      service: "{{{ ../service_name }}}",
      procedure: "{{{ procedure }}}",
      arguments: args,
    });
    // eslint-disable-next-line no-unused-vars
    const result = await new Promise<krpc.ProcedureResult>(
      (resolve, reject) => {
        this.conn.scheduleProcedureCall({
          procedureCall,
          resolve,
          reject,
        });
      }
    );
    {{{ before_return }}}
    return {{{ decoder_function }}};
  }

  {{/each}}
}

{{#each classes as |class| }}
export class {{{ class.name }}} {
  conn: KRPCConnection;
  id: Long;

  constructor(conn: KRPCConnection, id: Long) {
    this.conn = conn;
    this.id = id;
  }

  static decode(conn: KRPCConnection, result: Uint8Array) {
    const bb = ByteBuffer.wrap(result);
    return new {{{ class.name }}}(conn, bb.readVarint64());
  }

  {{#each class.methods as |method|}}

  async {{{ method.name }}}({{{ method.arguments_signature }}}): Promise<{{{ method.return_type_signature }}}> {
    const conn = this.conn;
    {{#if method.arguments }}
    const args: krpc.Argument[] = [];
    {{#each method.arguments as |argument|}}
    {{#if argument.optional}}
    if ({{{ argument.name }}} !== undefined) {
    {{/if}}
    args.push({
      position: {{{ argument.position }}},
      value: {{{ argument.encoder_function }}}({{{ argument.value }}}),
    });
    {{#if argument.optional}}
    }
    {{/if}}
    {{/each}}
    {{else}}
    const args: Array<krpc.Argument> = [];
    {{/if}}
    const procedureCall = krpc.ProcedureCall.fromPartial({
      service: "{{{ ../../service_name }}}",
      procedure: "{{{ procedure }}}",
      arguments: args,
    });
    // eslint-disable-next-line no-unused-vars
    const result = await new Promise<krpc.ProcedureResult>(
      (resolve, reject) => {
        this.conn.scheduleProcedureCall({
          procedureCall,
          resolve,
          reject,
        });
      }
    );
    {{#if before_return }}
    {{{ before_return }}}
    {{/if}}
    return {{{ decoder_function }}};
  }

  {{/each}}

  {{#each class.getters_setters as |method| }}
  async {{{ method.name }}}({{{ method.arguments_signature }}}): Promise<{{{ method.return_type_signature }}}> {
    const conn = this.conn;
    {{#if method.arguments }}
    const args: krpc.Argument[] = [];
    {{#each method.arguments as |argument|}}
    {{#if argument.optional}}
    if ({{{ argument.name }}} !== undefined) {
    {{/if}}
    args.push({
      position: {{{ argument.position }}},
      value: {{{ argument.encoder_function }}}({{{ argument.value }}}),
    });
    {{#if argument.optional}}
    }
    {{/if}}
    {{/each}}
    {{else}}
    const args: Array<krpc.Argument> = [];
    {{/if}}
    const procedureCall = krpc.ProcedureCall.fromPartial({
      service: "{{{ ../../service_name }}}",
      procedure: "{{{ procedure }}}",
      arguments: args,
    });
    // eslint-disable-next-line no-unused-vars
    const result = await new Promise<krpc.ProcedureResult>(
      (resolve, reject) => {
        this.conn.scheduleProcedureCall({
          procedureCall,
          resolve,
          reject,
        });
      }
    );
    {{{ before_return }}}
    return {{{ decoder_function }}};
  }

  {{/each}}
  // static methods
  {{#each class.static_methods as |method| }}
  static async {{{ method.name }}}(conn: KRPCConnection, {{{ method.arguments_signature }}}): Promise<{{{ method.return_type_signature }}}> {
    {{#if method.arguments }}
    const args: krpc.Argument[] = [];
    {{#each method.arguments as |argument|}}
    {{#if argument.optional}}
    if ({{{ argument.name }}} !== undefined) {
    {{/if}}
    args.push({
      position: {{{ argument.position }}},
      value: {{{ argument.encoder_function }}}({{{ argument.value }}}),
    });
    {{#if argument.optional}}
    }
    {{/if}}
    {{/each}}
    {{else}}
    const args: Array<krpc.Argument> = [];
    {{/if}}
    const procedureCall = krpc.ProcedureCall.fromPartial({
      service: "{{{ ../../service_name }}}",
      procedure: "{{{ procedure }}}",
      arguments: args,
    });
    // eslint-disable-next-line no-unused-vars
    const result = await new Promise<krpc.ProcedureResult>(
      (resolve, reject) => {
        conn.scheduleProcedureCall({
          procedureCall,
          resolve,
          reject,
        });
      }
    );
    {{{ before_return }}}
    return {{{ decoder_function }}};
  }

  {{/each}}
}
{{/each}}
